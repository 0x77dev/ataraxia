import debug from 'debug';
import { Event } from 'atvik';

import { WithNetwork } from '../WithNetwork';

import { Transport } from './Transport';

import { Peer } from './Peer';
import { TransportOptions } from './TransportOptions';
import { IdMap, compareId, encodeId } from '../id';
import { isMergeablePeer } from './MergeablePeer';

/**
 * Abstract base for implementing transports. Implements common behavior to
 * help with tracking of peers.
 */
export class AbstractTransport
	implements Transport
{
	private readonly transportName: string;

	private readonly peerConnectEvent: Event<this, [ Peer ]>;
	private readonly peerDisconnectEvent: Event<this, [ Peer ]>;

	protected debug: debug.Debugger;

	private _started: boolean;

	private _network?: WithNetwork;
	protected readonly peers: IdMap<Peer>;

	constructor(name: string) {
		this.peerConnectEvent = new Event(this);
		this.peerDisconnectEvent = new Event(this);

		this.peers = new IdMap();

		this._started = false;
		this.transportName = name;
		this.debug = debug('ataraxia:no-network:' + name);
	}

	/**
	 * Event for when a new peer is connected via this transport.
	 */
	get onPeerConnect() {
		return this.peerConnectEvent.subscribable;
	}

	/**
	 * Event for when a peer is disconnected.
	 */
	get onPeerDisconnect() {
		return this.peerDisconnectEvent.subscribable;
	}

	/**
	 * Get if transport is started.
	 */
	get started() {
		return this._started;
	}

	/**
	 * Get the network of this transport.
	 */
	protected get network(): WithNetwork {
		if(! this._network) {
			throw new Error('Can\'t access network before start() is called');
		}

		return this._network;
	}

	/**
	 * Start this transport.
	 *
	 * @param {object} options
	 *   Options as generated by the network instance. Contains `id` which is
	 *   a generated id of the local peer, `name` which is the short name of
	 *   the network (used for things such as discovery) and `endpoint` which
	 *   is a boolean indicating if the network wants to perform routing.
	 * @returns
	 *   Boolean indicating if the transport was started.
	 */
	public async start(options: TransportOptions): Promise<boolean> {
		if(this._started) {
			return false;
		}

		this.debug = debug('ataraxia:' + options.networkName + ':' + this.transportName);
		this._started = true;

		this.debug('Starting with id ' + encodeId(options.networkId));

		this._network = {
			networkId: options.networkId,
			debugNamespace: this.debug.namespace,
			authentication: options.authentication
		};

		return true;
	}

	/**
	 * Stop this transport.
	 *
	 * @returns
	 *   Boolean indicating if the transport was stopped.
	 */
	public async stop(): Promise<boolean> {
		if(! this._started) {
			return false;
		}

		for(const peer of this.peers.values()) {
			peer.disconnect();
		}

		this._started = false;
		return true;
	}

	/**
	 * Add a peer to this transport.
	 *
	 * @param {Peer} peer
	 */
	protected addPeer(peer: Peer) {
		peer.onConnect(() => {
			const existingPeer = this.peers.get(peer.id);
			if(existingPeer) {
				/*
				 * This peer is already available via this transport. Compare
				 * the identifiers and disconnect ourselves if our id is
				 * smaller than the peers id.
				 *
				 */
				const compared = compareId(this.network.networkId, peer.id);
				if(compared < 0) {
					this.debug('Peer with id', encodeId(peer.id), 'exists and is larger than our id, disconnecting existing peer');
					existingPeer.disconnect();

					if(isMergeablePeer(peer)) {
						peer.merge(existingPeer as any);
					}

					// Emit event for the new peer once the existing one has disconnected
					existingPeer.onDisconnect.once()
						.then(() => {
							this.peers.set(peer.id, peer);
							this.peerConnectEvent.emit(peer);
						});
				} else {
					this.debug('Peer with id', encodeId(peer.id), 'exists and is smaller than our id, disconnecting new peer');
					peer.disconnect();

					if(isMergeablePeer(existingPeer)) {
						existingPeer.merge(peer as any);
					}
				}
			} else {
				// New peer, connect to it
				this.peers.set(peer.id, peer);

				this.peerConnectEvent.emit(peer);
			}
		});

		peer.onDisconnect(() => {
			const stored = this.peers.get(peer.id);
			if(stored === peer) {
				this.peers.delete(peer.id);

				this.peerDisconnectEvent.emit(peer);
			}
		});
	}
}
