'use strict';

const debug = require('debug');
const { EventEmitter } = require('events');

/**
 * Abstract base for implementing transports. Implements common behavior to
 * help with tracking of peers.
 */
module.exports = class AbstractTransport {
	constructor(name) {
		this.events = new EventEmitter(this);
		this.peers = new Map();

		this.started = false;
		this.debug = debug('ataraxia:' + name);
	}

	/**
	 * Register an event handler. Events are available for `connected` and
	 * `disconnected` both with a payload of a Peer.
	 *
	 * @param {string} event
	 * @param {function} handler
	 */
	on(event, handler) {
		this.events.on(event, handler);
	}

	/**
	 * Remove a previously registered event handler.
	 *
	 * @param {string} event
	 * @param {function} handler
	 */
	off(event, handler) {
		this.events.removeListener(event, handler);
	}

	/**
	 * Start this transport.
	 *
	 * @param {object} options
	 *   Options as generated by the network instance. Contains `id` which is
	 *   a generated id of the local peer, `name` which is the short name of
	 *   the network (used for things such as discovery) and `endpoint` which
	 *   is a boolean indicating if the network wants to perform routing.
	 * @returns
	 *   Boolean indicating if the transport was started.
	 */
	start(options) {
		if(this.started) {
			return false;
		}

		this.debug('Starting with id `' + options.id + '`');
		this.started = true;
		this.networkId = options.id;

		return true;
	}

	/**
	 * Stop this transport.
	 *
	 * @returns
	 *   Boolean indicating if the transport was stopped.
	 */
	stop() {
		if(! this.started) {
			return false;
		}

		for(const peer of this.peers.values()) {
			peer.disconnect();
		}

		this.started = false;
		return true;
	}

	/**
	 * Add a peer to this transport.
	 *
	 * @param {Peer} peer
	 */
	addPeer(peer) {
		peer.on('connected', () => {
			if(peer.id === this.networkId) {
				// This peer points to ourself, ignore it
				this.debug('Connected to self, requesting disconnect');
				peer.disconnect();
				return;
			}

			if(this.peers.has(peer.id)) {
				/*
				 * This peer is already available via this transport. Two
				 * options:
				 *
				 * 1) Merge the peers if the peer-implementation supports it
				 * 2) Disconnect this peer
				 */
				if(peer.merge) {
					this.peers.get(peer.id).merge(peer);
				} else {
					peer.disconnect();
				}
			} else {
				// New peer, connect to it
				this.peers.set(peer.id, peer);

				this.events.emit('connected', peer);
			}
		});

		peer.on('disconnected', () => {
			const stored = this.peers.get(peer.id);
			if(stored === peer) {
				this.peers.delete(peer.id);

				this.events.emit('disconnected', peer);
			}
		});
	}
};
